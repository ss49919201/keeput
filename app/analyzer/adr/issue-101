https://github.com/ss49919201/keeput/issues/101

# タイトル
複数プラットフォームの最新アウトプットを並列フェッチし、公開日時優先＋プラットフォーム優先度で1件選択する

# コンテキスト
- issue #101 で「最新アウトプット」の選択に複数プラットフォーム（Hatena、Zenn など）を考慮したい要望が出た。
- 現状の Analyze usecase は優先度リストの先頭（事実上 Hatena）の fetcher だけを注入し、他プラットフォームを見ない。
- 優先度（priority）はドメインで既に定義済みで、順序を保ったまま選択ポリシーを拡張する必要がある。
- 設計方針としてオブジェクト指向ではなく、関数を配列で DI して合成する関数型寄りの形を希望。

# 決定
- Usecase に fetchLatest 関数の配列を注入し、並列で全 fetcher を実行する。
- 取得結果を一つの配列にマージし、(1) PublishedAt 降順、(2) 同日時なら priority 昇順で 1 件だけ採用する。
- 個別プラットフォームの失敗は warn ログを残してスキップし、全プラットフォーム失敗時のみエラーとして扱う。
- 優先度テーブルはドメイン側の純関数／定数で管理し、URL や HTTP などの技術的詳細は各 fetcher アダプタに閉じ込める。 Usecase は配列に渡された関数を純粋にオーケストレーションするだけに留める。

## 採用した方針
- シンプル並列＋逐次選択を採用する。`errgroup` などで全 fetcher を並列実行し、結果スライスを単純ループで (PublishedAt desc → priority asc) のキーで選択する。
- 理由: レイテンシを並列で抑えつつ、実装が平坦でテスト容易。ロジックが純関数に近く回帰リスクが低い。

## 採用しなかった方針
- 早期打ち切り付き並列: 早期終了条件の分岐とテストパスが増え、保守性（回帰リスク）が悪化するため今回は見送り。
  - 例: 最優先プラットフォームの結果が届いたら即終了するか、24h以内の新着なら打ち切るか、タイムアウト時に未完 fetch を無視して決定するか、同日時で優先度が逆転する可能性がある場合に待つかどうか等の分岐が増える。
- キャッシュ＋並列のハイブリッド: キャッシュ失効や同時更新の境界ケースが増え回帰リスクが高い。現状の負荷・要件では過剰最適化と判断して見送り。
  - 例: 有効期限直前の並行リクエストで片方が古い値を返す揺らぎ、取得中に失効して古い値で上書きする競合、プラットフォームごとの失効タイミング差で優先順位が誤って逆転、失敗をネガティブキャッシュするかどうか、失効直後のスタンピード制御が必要になる等。
